#!/usr/bin/env python3
#
# Generates a setup.py to create a python wheel for non-python artifacts.
# It's a bit of a hack, but it frees us to only have users deal with pip
# when installing packages.
#
# This can only install artifacts to the python 'prefix', which on RoboRIO
# we have set to /usr/local
#
# Ideally, we would create platform-specific wheels. Unfortunately, wheels
# do not currently support symlinks
#
# .. sigh, this will break in pip 21.0 because https://github.com/pypa/pip/issues/8368
#

import argparse
import inspect
import os
import os.path
import subprocess
import typing

setup_py_tmpl = inspect.cleandoc(
    """
    #!/usr/bin/env python3
    #
    # Automatically generated by gen_setup_py.py
    #

    from setuptools import setup
    
    setup(
        name=%(name)r,
        version=%(version)r,
        license=%(license)r,
        install_requires=%(install_requires)r,
        url=%(url)r,
        maintainer="RobotPy",
        maintainer_email="robotpy@googlegroups.com",
        data_files=%(data_files)r,
    )

"""
)


def get_soname(path: str) -> str:
    output = subprocess.check_output(["objdump", "-p", path], encoding="utf-8")
    for line in output.splitlines():
        if line.startswith("  SONAME"):
            _, libname = line.split()
            return libname

    raise ValueError(f"SONAME not found for `{path}`")


def enforce_structure(prefix: str, soname_must_match: bool) -> typing.List[str]:
    # Can only install files to the python prefix, which is /usr/local
    data_files = []
    for root, _, files in os.walk(prefix):
        root_files = []
        for fname in files:
            full_fname = os.path.join(root, fname)
            if os.path.islink(full_fname):
                raise ValueError(f"{full_fname}: is a symlink")

            if (
                (fname.endswith("so") or ".so." in fname)
                and not fname.endswith(".debug")
                and not fname.endswith("-arm-linux-gnueabi.so")
            ):
                soname = get_soname(full_fname)
                if soname_must_match != (soname == fname):
                    raise ValueError(f"{full_fname}: SONAME is {soname}")

            root_files.append(full_fname)

        if root_files:
            root = os.path.relpath(root, prefix)
            data_files.append((root, root_files))

    return data_files


def gen_setup_py(data_py_fname: str, setup_py_fname: str, dev: bool, dbg: bool):
    data = {}

    with open(data_py_fname) as fp:
        exec(fp.read(), data)

    if dbg or dev:
        data["install_requires"] = [data["name"] + "==" + data["version"]]
    if dbg:
        data["name"] = data["name"] + "-dbg"
    if dev:
        data["name"] = data["name"] + "-dev"
        data["install_requires"].extend(data.get("install_dev_requires", []))

    # enforce library restrictions
    # -> normal package must have .so that match SONAME
    # -> dev package must not have .so that match SONAME
    data_files = enforce_structure("usr/local", soname_must_match=not dev)
    data["data_files"] = data_files

    setup_py = setup_py_tmpl % data

    with open(setup_py_fname, "w") as fp:
        fp.write(setup_py)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("data_py")
    parser.add_argument("setup_py")
    parser.add_argument("--dev", action="store_true", default=False)
    parser.add_argument("--dbg", action="store_true", default=False)

    args = parser.parse_args()
    gen_setup_py(args.data_py, args.setup_py, args.dev, args.dbg)
